main.py :

служба рассылки сообщений, которая отправляет сообщения из очереди получателям с использованием протокола
Simple Mail Transfer Protocol (SMTP). Сценарий реализован с использованием smtplib библиотеки для отправки электронных
писем и schedule библиотеки для планирования отправки сообщений через регулярные промежутки времени.

Ниже приведен краткий обзор скрипта:

Импорт необходимых пакетов: скрипт начинается с импорта необходимых пакетов Python, включая time, MIMEMultipart, MIMEText, smtplib os и,,,.

Определить функцию send_messag():
 эта функция отвечает за отправку сообщений из очереди.
Она извлекает данные сообщения с помощью get_data() функции из GetData модуля.
 Если сообщение получено успешно, оно подготавливает сообщение электронной почты с необходимыми заголовками
 (От, Кому, тема и тело сообщения), используя MIMEMultipart и MIMEText объекты.

Отправка электронной почты:
функция создает SMTP-сервер с использованием smtplib.SMTP класса и подключается к
SMTP-серверу, используя учетные данные, указанные в переменных среды (Email и пароль). Затем оно отправляет сообщение
 электронной почты, используя server.sendmail() метод.

Запланируйте отправку сообщений:
 скрипт использует schedule библиотеку для планирования запуска send_messag()
 функции каждые 10 секунд. schedule.every(10).seconds.do(send_messag) Строка настраивает запланированное задание для
 выполнения send_messag() функции через указанный интервал.

Основной цикл:
 скрипт входит в цикл while, который непрерывно проверяет наличие ожидающих выполнения запланированных
 заданий с помощью schedule.run_pending(). time.sleep(1) Инструкция вводит задержку в 1 секунду между проверками,
 чтобы избежать чрезмерной загрузки процессора.

Пожалуйста, обратите внимание, что этот скрипт предназначен для непрерывной работы, и он будет продолжать отправлять
сообщения из очереди с указанным интервалом (в данном случае каждые 10 секунд), пока скрипт запущен.

Перед запуском скрипта убедитесь, что необходимые переменные среды (Email, SMTP_server SMTP_PORTи password) установлены правильно,
чтобы облегчить успешную отправку электронной почты. Кроме того, убедитесь, что GetData модуль содержит необходимые функции для
извлечения сообщений из очереди и обновления статуса сообщения.

Чтобы остановить скрипт, вы можете прервать выполнение (например, нажав Ctrl+C в консоли).

GetData.py:

скрипт на Python содержит функции, связанные с взаимодействием с базой данных с использованием SQLAlchemy.
Скрипт использует SQLAlchemy для создания сеанса, извлечения данных из базы данных и обновления статуса сообщения.
get_data() Функция извлекает первое сообщение со статусом 0 (ожидание) из базы данных, а update_message() функция обновляет статус сообщения в базе данных.

Ниже приведено краткое объяснение каждой функции:

get_data() Функция:
Эта функция извлекает первое ожидающее сообщение (со статусом 0) из базы данных.
Оно использует возможности запросов SQLAlchemy для фильтрации сообщений по статусу 0 и сортирует их по их id возрастанию.
Затем оно извлекает первое сообщение из отфильтрованного списка, если таковое имеется, и возвращает его.
Если ожидающих сообщений нет, функция возвращает False.

update_message(messag, status) Функция:
Эта функция обновляет статус данного сообщения в базе данных. Оно принимает два параметра: messag,
который является объектом сообщения, подлежащим обновлению, и status, который является новым значением статуса,
которое необходимо установить. Функция обновляет status и datatime атрибуты сообщения с предоставленными значениями.
Затем она добавляет обновленный объект message в сеанс и фиксирует изменения в базе данных.

Пожалуйста, обратите внимание, что функции зависят от Message модели model модуля,
который предположительно определяет схему таблицы базы данных для сообщений.

Перед использованием этих функций убедитесь, что model.py файл содержит необходимые определения модели
SQLAlchemy для Message и любых других соответствующих таблиц. Кроме того, убедитесь, что файл базы данных MassEmail.db
присутствует и доступен в текущем рабочем каталоге или по пути, указанному в create_engine() вызове.

Чтобы интегрировать эти функции с остальной частью службы рассылки сообщений, вы можете использовать их в send_messag()
функции для извлечения сообщений из очереди и обновления их статуса после отправки.

model.py:

Код Python определяет модели и сопоставления SQLAlchemy для таблиц message и user.
Эти модели будут представлять соответствующие таблицы базы данных и определять схему для сообщений и пользовательских данных.
Код настраивает необходимые метаданные, таблицы и сопоставления классов с использованием подхода декларативного сопоставления SQLAlchemy.

Вот обзор кода:

Импорт необходимых пакетов:
код импортирует необходимые пакеты из SQLAlchemy, включая MetaData, Table, Column и registry.

Определите схемы таблиц: код определяет две таблицы:
message и user. Каждая таблица соответствует определенной таблице базы данных, и каждый столбец в таблице определяется с
помощью Column класса. Схема таблицы включает столбцы для хранения различных атрибутов сообщений и пользователей, таких
как id, to subject, message type status, system datatime nameusername, email password

Определение сопоставлений классов:
код использует registry для определения сопоставлений классов для Message и User моделей. registry представляет собой
контейнер для отображения декларативных классов и позволяет связывать классы Python с соответствующими таблицами базы данных.
map_imperatively() Метод используется для создания сопоставлений между классами Python Message и User и таблицами message и user соответственно.

Определите пустые классы:
В коде определены два пустых класса Python, Message и User.
Эти классы будут действовать как декларативная база для определения классов модели и связывания их с соответствующими
таблицами базы данных. Фактические атрибуты и методы этих классов будут добавлены динамически на основе схем таблиц,
определенных ранее.

Предоставленный код является первым шагом в определении моделей SQLAlchemy для сообщений и пользовательских данных.
Чтобы использовать эти модели для взаимодействия с базой данных, вам необходимо создать SQLAlchemy Session и выполнять
операции CRUD (создание, чтение, обновление, удаление) над таблицами.

Например, для извлечения сообщений из message таблицы вы можете создать Session, запросить Message модель и выполнить
запросы для извлечения данных из таблицы. Аналогичным образом вы можете использовать Session для добавления новых сообщений,
обновления существующих сообщений или удаления сообщений.

Пожалуйста, обратите внимание, что предоставленный код определяет только схемы таблиц и сопоставления классов.
Для завершения настройки и выполнения операций с базой данных вам нужно будет создать Session, подключиться к
database engine и выполнить необходимые запросы.