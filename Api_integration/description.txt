main.py:

код представляет собой приложение FastAPI, которое служит в качестве API для выполнения различных операций. Оно включает пользовательскую схему OpenAPI и запускает приложение FastAPI с использованием сервера Uvicorn на указанном хосте и порту.

Давайте разберем код:

FastAPI и get_openapi: FastAPI - это веб-фреймворк для создания API на Python. get_openapi Функция используется для генерации схемы OpenAPI для API.

insert_messag: Код импортирует модуль с именем insert_messag (вероятно, модуль приложения, который обрабатывает вставку сообщений).

app: app это экземпляр FastAPI, который будет основным приложением для обработки запросов API.

app.include_router: Оно включает маршрутизатор из insert_messag модуля с префиксом "/api/v1". Это означает, что маршруты, определенные в insert_messag маршрутизаторе, будут доступны по URL-адресу "/api/v1".

custom_openapi: Эта функция генерирует пользовательскую схему OpenAPI для API. Она задает название, версию и описание API.

app.openapi: Эта строка назначает custom_openapi функцию в качестве пользовательской схемы OpenAPI для приложения FastAPI.

uvicorn.run: uvicorn.run Функция используется для запуска приложения FastAPI. Оно запускает сервер Uvicorn с указанным хостом и портом. os.environ.get('PORT_API') используется для получения номера порта из переменных среды. host="0.0.0.0" означает, что приложение будет доступно из любого сетевого интерфейса.

вкратце, предоставленный код настраивает приложение FastAPI, включает маршруты из insert_messag модуля, генерирует пользовательскую схему OpenAPI и запускает приложение с помощью Uvicorn server. Приложение будет служить в качестве API для выполнения различных операций, вероятно, включая вставку сообщений в систему.

insert_messag.py:

 код представляет собой приложение FastAPI, которое определяет конечную точку API для вставки сообщений в очередь. Приложение использует SQLAlchemy для взаимодействия с базой данных SQLite, где хранятся данные сообщений. API принимает полезную нагрузку в формате JSON с подробными сведениями о сообщении и вставляет сообщения в базу данных в виде записей в таблице "Сообщения".

Давайте разберем код:

fastapi.APIRouter: Код создает новый экземпляр APIRouter, который используется для определения маршрутов API.

messag_param: messag_param это Pydantic BaseModel, который определяет ожидаемую структуру полезной нагрузки запроса. Оно включает поля для "кому" (список получателей), "тема", "сообщение", "тип" (способ отправки) и "система" (система происхождения сообщения).

out: out это еще один Pydantic BaseModel, который определяет модель ответа для конечной точки API. Оно включает поля для "err" (сообщение об ошибке, если таковое имеется) и "messag_states" (логическое значение, указывающее состояние успешной вставки сообщений в очередь).

novelroute: novelroute APIRouter используется для определения конечной точки API для вставки сообщений. Конечная точка доступна по адресу "/insert-messag" с помощью метода HTTP POST.

@novelroute.post('insert-messag', response_model=out, tags=["Заптсь сообщения в очередь"]): Это декоратор конечной точки API. Он указывает, что функция "insert_message" обрабатывает POST-запросы к URL-адресу "/insert-messag". response_model=out Аргумент указывает FastAPI сверять данные ответа с out моделью. Аргумент "теги" добавляет тег к конечной точке для группировки в документации OpenAPI.

insert_message функция: Эта функция является обработчиком для конечной точки "/insert-messag". Она получает полезную нагрузку запроса с деталями сообщения в качестве param параметра.

Внутри функции создается новый сеанс SQLAlchemy для взаимодействия с базой данных SQLite. Для каждого получателя в списке "кому" создается новый Message объект и заполняется сведениями о сообщении. Статус сообщения устанавливается равным 0 (что указывает на то, что оно находится в очереди). Затем сообщение добавляется в сеанс и фиксируется в базе данных.

Если во время работы базы данных возникает какое-либо исключение, функция присваивает полю "err" ответа на сообщение об ошибке и "messag_states" значение False, что указывает на невозможность вставки сообщений в очередь.

Функция возвращает модель ответа (out), преобразованную в словарь.

вкратце, предоставленное приложение FastAPI определяет конечную точку API, которая принимает полезную нагрузку JSON с подробными сведениями о сообщении и вставляет сообщения в базу данных SQLite. Приложение использует SQLAlchemy для взаимодействия с базой данных и Pydantic для проверки данных запроса и ответа.

model.py:

код использует таблицу и реестр SQLAlchemy для определения таблиц базы данных для модели сообщений и пользовательских данных. Код создает две таблицы, "сообщение" и "Пользователь", и связывает их с классами Python Message и User с помощью map_imperatively функции SQLAlchemy.

Давайте разберем код:

metadata = MetaData(): metadata Объект представляет собой коллекцию табличных объектов и связанных с ними метаданных. Он содержит информацию о схеме базы данных и используется для определения структуры таблиц.

mapper_registry = registry()mapper_registry Является экземпляром registry класса SQLAlchemy, который действует как центральное хранилище для сопоставлений между классами Python и таблицами базы данных.

message и user таблицы: код определяет две таблицы, "сообщение" и "Пользователь", используя Table класс из SQLAlchemy. Каждая таблица связана с определенным классом Python (Message и User соответственно).

Для таблицы "сообщения":

В таблице есть столбцы "идентификатор" (первичный ключ), "кому", "тема", "сообщение", "тип", "статус", "система" и "дата".
Столбцы "кому", "тема", "сообщение", "тип" и "система" имеют тип String и помечены как не обнуляемые (nullable=False).
Столбец "статус" имеет тип Integer и помечен как не обнуляемый.
Столбец "datatime" имеет тип DATETIME и помечен как не обнуляемый.
Для таблицы "User":

В таблице есть столбцы "id" (первичный ключ), "имя", "имя пользователя", "электронная почта" и "пароль".
Столбцы "имя", "имя пользователя", "электронная почта" и "пароль" имеют тип String, и они помечены как не обнуляемые.
class Message(object) и class User(object): Код определяет два пустых класса Python, Message и User, которые будут использоваться для представления строк из таблиц "сообщение" и "Пользователь" соответственно. Эти классы необходимы для системы ORM (объектно-реляционного отображения) SQLAlchemy для сопоставления объектов Python со строками базы данных.

mapper_registry.map_imperatively(Message, message) и mapper_registry.map_imperatively(User, user): В этих строках используется map_imperatively функция из mapper_registry, чтобы связать классы Message и User с таблицами "сообщение" и "Пользователь" соответственно. Это устанавливает сопоставление между классами Python и таблицами базы данных, позволяя SQLAlchemy выполнять операции с базой данных, используя определенные классы.

вкратце, предоставленный код настраивает SQLAlchemy для работы с двумя таблицами базы данных, "message" и "User", используя классы Python Message и User в качестве моделей ORM. Определенные таблицы представляют структуру данных сообщений и пользовательских объектов в базе данных, а модели ORM позволяют разработчикам взаимодействовать с базой данных, используя объекты и классы Python.

